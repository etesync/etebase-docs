"use strict";(self.webpackChunketebase_docs=self.webpackChunketebase_docs||[]).push([[338],{3905:function(e,t,n){n.d(t,{Zo:function(){return r},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function m(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?m(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):m(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},m=Object.keys(e);for(a=0;a<m.length;a++)n=m[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(e);for(a=0;a<m.length;a++)n=m[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},r=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,m=e.originalType,l=e.parentName,r=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=i,_=p["".concat(l,".").concat(u)]||p[u]||d[u]||m;return n?a.createElement(_,o(o({ref:t},r),{},{components:n})):a.createElement(_,o({ref:t},r))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var m=n.length,o=new Array(m);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<m;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8215:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(7294);function i(e){var t=e.children,n=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:i},t)}},3709:function(e,t,n){n.d(t,{Z:function(){return d}});var a=n(7294),i=n(7462),m=n(2389),o=n(5979),s=n(6010),l="tabItem_LplD";function c(e){var t,n,m,c=e.lazy,r=e.block,d=e.defaultValue,p=e.values,u=e.groupId,_=e.className,g=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),h=null!=p?p:g.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),b=(0,o.lx)(h,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var k=null===d?d:null!=(t=null!=d?d:null==(n=g.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(m=g[0])?void 0:m.props.value;if(null!==k&&!h.some((function(e){return e.value===k})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+h.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var f=(0,o.UB)(),v=f.tabGroupChoices,y=f.setTabGroupChoices,T=(0,a.useState)(k),I=T[0],N=T[1],w=[],M=(0,o.o5)().blockElementScrollPositionUntilNextRender;if(null!=u){var E=v[u];null!=E&&E!==I&&h.some((function(e){return e.value===E}))&&N(E)}var O=function(e){var t=e.currentTarget,n=w.indexOf(t),a=h[n].value;a!==I&&(M(t),N(a),null!=u&&y(u,a))},x=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=w.indexOf(e.currentTarget)+1;n=w[a]||w[0];break;case"ArrowLeft":var i=w.indexOf(e.currentTarget)-1;n=w[i]||w[w.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":r},_)},h.map((function(e){var t=e.value,n=e.label,m=e.attributes;return a.createElement("li",(0,i.Z)({role:"tab",tabIndex:I===t?0:-1,"aria-selected":I===t,key:t,ref:function(e){return w.push(e)},onKeyDown:x,onFocus:O,onClick:O},m,{className:(0,s.Z)("tabs__item",l,null==m?void 0:m.className,{"tabs__item--active":I===t})}),null!=n?n:t)}))),c?(0,a.cloneElement)(g.filter((function(e){return e.props.value===I}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},g.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==I})}))))}function r(e){var t=(0,m.Z)();return a.createElement(c,(0,i.Z)({key:String(t)},e))}function d(e){var t=e.children;return a.createElement(r,{defaultValue:"js",groupId:"programming-language",values:[{label:"JavaScript",value:"js"},{label:"Python",value:"py"},{label:"Java",value:"java"},{label:"Kotlin",value:"kt"},{label:"C/C++",value:"c"},{label:"Rust",value:"rs"}]},t)}},9452:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return r},default:function(){return g},frontMatter:function(){return c},metadata:function(){return d},toc:function(){return u}});var a=n(7462),i=n(3366),m=(n(7294),n(3905)),o=n(3709),s=n(8215),l=["components"],c={title:"Using Items"},r=void 0,d={unversionedId:"guides/using_items",id:"guides/using_items",title:"Using Items",description:"This section assumes you have already read the overview and understand what collections and items are and what each are for.",source:"@site/docs/guides/using_items.mdx",sourceDirName:"guides",slug:"/guides/using_items",permalink:"/guides/using_items",editUrl:"https://github.com/etesync/etebase-docs/edit/master/docs/guides/using_items.mdx",tags:[],version:"current",frontMatter:{title:"Using Items"},sidebar:"someSidebar",previous:{title:"Using Collections",permalink:"/guides/using_collections"},next:{title:"Collection Sharing",permalink:"/guides/collection_sharing"}},p={},u=[{value:"Prerequisite: have a collection",id:"prerequisite-have-a-collection",level:2},{value:"Creating items",id:"creating-items",level:2},{value:"Fetching items",id:"fetching-items",level:2},{value:"Simple fetch",id:"simple-fetch",level:3},{value:"Only fetch recent changes",id:"only-fetch-recent-changes",level:3},{value:"Fetch in chunks",id:"fetch-in-chunks",level:3},{value:"Fetch by <code>uid</code>",id:"fetch-by-uid",level:3},{value:"Fetch multiple by <code>uid</code>",id:"fetch-multiple-by-uid",level:3},{value:"Fetch a group of items",id:"fetch-a-group-of-items",level:3},{value:"Modifying and deleting items",id:"modifying-and-deleting-items",level:2},{value:"Uploading multiple items",id:"uploading-multiple-items",level:2},{value:"Advanced uploads and transactions",id:"advanced-uploads-and-transactions",level:2},{value:"Transactions",id:"transactions",level:3},{value:"Using <code>stoken</code>",id:"using-stoken",level:3},{value:"Additional dependencies",id:"additional-dependencies",level:3},{value:"Treating collections as items",id:"treating-collections-as-items",level:3},{value:"Subscriptions (live updates)",id:"subscriptions-live-updates",level:2},{value:"Binary content",id:"binary-content",level:2}],_={toc:u};function g(e){var t=e.components,n=(0,i.Z)(e,l);return(0,m.kt)("wrapper",(0,a.Z)({},_,n,{components:t,mdxType:"MDXLayout"}),(0,m.kt)("p",null,"This section assumes you have already read ",(0,m.kt)("a",{parentName:"p",href:"../overview"},"the overview")," and understand what collections and items are and what each are for."),(0,m.kt)("p",null,"Items are very similar to collections in how you interact with them, so this section may look familiar, especially if you just finished the previous one. However, there are some differences, especially when uploading data."),(0,m.kt)("h2",{id:"prerequisite-have-a-collection"},"Prerequisite: have a collection"),(0,m.kt)("p",null,"This section assumes you already have a collection created and uploaded. We already covered it in the previous section, but as a reminder:"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},'const etebase = await Etebase.Account.login("username", "password");\nconst collectionManager = etebase.getCollectionManager();\nconst collection = await collectionManager.create("cyberdyne.files",\n  {\n    name: "My files",\n    description: "A collection of files of different types",\n  },\n  ""\n);\nawait collectionManager.upload(collection);\n'))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},'from etebase import Client, Account\n\nclient = Client("client-name")\netebase = Account.login(client, "username", "password")\n\ncol_mgr = etebase.get_collection_manager()\n\n# Create, encrypt and upload a new collection\ncollection = col_mgr.create("cyberdyne.calendar",\n    {\n        "name": "Holidays",\n        "description": "My holiday calendar",\n        "color": "#23aabbff",\n    },\n    "" # Empty content\n)\ncol_mgr.upload(collection)\n'))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},'import com.etebase.client.*;\n\nClient client = Client.create(httpClient, null);\nAccount etebase = Account.login(client, "username", "password");\n\nCollectionManager colMgr = etebase.getCollectionManager();\n\n// Create, encrypt and upload a new collection\nItemMetadata collectionMetadata = new ItemMetadata();\ncollectionMetadata.setName("Holidays");\ncollectionMetadata.setDescription("My holiday calendar");\ncollectionMetadata.setColor("#23aabbff");\nCollection collection = colMgr.create("cyberdyne.calendar", collectionMetadata, "");\n\ncolMgr.upload(collection);\n'))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},'import com.etebase.client.*\n\nval client = Client.create(httpClient, null)\nval etebase = Account.login(client, "username", "password")\n\nval colMgr = etebase.collectionManager\n\n// Create, encrypt and upload a new collection\ncollectionMetadata.name = "Holidays"\ncollectionMetadata.description = "My holiday calendar"\ncollectionMetadata.color = "#23aabbff"\nval collection = colMgr.create("cyberdyne.calendar", collectionMetadata, "")\n\ncolMgr.upload(collection)\n'))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},'const char *server_url = etebase_get_default_server_url();\nEtebaseClient *client = etebase_client_new("client-name", server_url);\nEtebaseAccount *etebase = etebase_account_login(client, "username", "password");\n\n// Create, encrypt and upload a new collection\nEtebaseCollectionManager *col_mgr = etebase_account_get_collection_manager(etebase);\nEtebaseItemMetadata *col_meta = etebase_collection_metadata_new();\netebase_collection_metadata_set_name(col_meta, "Holidays");\netebase_collection_metadata_set_description(col_meta, "My holiday calendar");\netebase_collection_metadata_set_color(col_meta, "#23aabbff");\nEtebaseCollection *col = etebase_collection_manager_create(col_mgr, "cyberdyne.calendar", col_meta, "", 0);\netebase_collection_metadata_destroy(col_meta);\n\netebase_collection_manager_upload(col_mgr, col, NULL);\n\n// Cleanup\netebase_collection_destroy(col);\netebase_collection_manager_destroy(col_mgr);\n'))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},'use etebase::{Account, Client, ItemMetadata};\n\nlet client = Client::new(..., server_url)?;\nlet etebase = Account::login(client, "username", "password")?;\n\nlet collection_manager = etebase.collection_manager()?;\n\n// Create, encrypt and upload a new collection\nlet collection = collection_manager.create(\n    "cyberdyne.calendar",\n    ItemMetadata::new()\n        .set_name(Some("Holidays"))\n        .set_description(Some("My holiday calendar"))\n        .set_color(Some("#23aabbff")),\n    &[], // Empty content\n)?;\ncollection_manager.upload(&collection, None)?;\n')))),(0,m.kt)("h2",{id:"creating-items"},"Creating items"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},'// We can reuse the collection and manager from above\nconst collectionManager = ...;\nconst collection = ...;\n\n// Similar to how we have collection manager\nconst itemManager = collectionManager.getItemManager(collection);\n\n// Create, encrypt and upload a new item\nconst item = await itemManager.create(\n  {\n    type: "file",\n    name: "note.txt",\n    mtime: (new Date()).getTime(),\n  },\n  "My secret note",\n);\nawait itemManager.batch([item]);\n'))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},'import time\n\n# We can reuse the collection and manager from above\ncol_mgr = ...\ncollection = ...\n\n# Similar to how we have a collection manager\nitem_mgr = col_mgr.get_item_manager(collection)\n\n# Create, encrypt and upload a new item\nitem = item_mgr.create(\n    {\n        "type": "file",\n        "name": "note.txt",\n        "mtime": int(round(time.time() * 1000))\n    },\n    b"My secret note"\n)\nitem_mgr.batch([item])\n'))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},'CollectionManager colMgr = ...;\nCollection collection = ...;\n\n// Similar to how we have collection manager\nItemManager itemManager = colMgr.getItemManager(collection);\n\n// Create, encrypt and upload a new item\nItemMetadata meta = new ItemMetadata();\nmeta.setType("file");\nmeta.setName("note.txt");\nmeta.setMtime((new Date()).getTime());\nItem item = itemManager.create(meta, "My secret note");\nitemManager.batch(new Item[] {item});\n'))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},'val colMgr = ...\nval collection = ...\n\n// Similar to how we have collection manager\nval itemManager = colMgr.getItemManager(collection)\n\n// Create, encrypt and upload a new item\nval meta = ItemMetadata()\nmeta.type = "file"\nmeta.name = "note.txt"\nmeta.mtime = Date().getTime()\nval item = itemManager.create(meta, "My secret note")\nitemManager.batch(arrayOf(item))\n'))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},'EtebaseCollectionManager *col_mgr = ...;\nEtebaseCollection *col = ...;\n\n// Similar to how we have collection manager\nEtebaseItemManager *item_mgr = etebase_collection_manager_get_item_manager(col_mgr, col);\n\n// Create, encrypt and upload a new item\nEtebaseItemMetadata *item_meta = etebase_item_metadata_new();\netebase_item_metadata_set_item_type(item_meta, "file");\netebase_item_metadata_set_name(item_meta, "note.txt");\ntime_t now = time(NULL);\nif (now == (time_t)(-1)) {\n    // Error\n}\nnow *= 1000;\netebase_item_metadata_set_mtime(item_meta, &now);\nconst char item_content[] = "My secret note";\nEtebaseItem *item = etebase_item_manager_create(item_mgr, item_meta, item_content, strlen(item_content));\n\nconst EtebaseItem *items[] = { item };\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n\netebase_item_destroy(item);\netebase_item_manager_destroy(item_mgr);\n'))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},'let collection_manager = ...\nlet collection = ...\n\n// Similar to how we have collection manager\nlet item_manager = collection_manager.item_manager(collection, None)?;\n\n// Create, encrypt and upload a new item\nlet item = item_manager.create(\n    ItemMetadata::new()\n        .set_item_type("files")\n        .set_name("note.txt"),\n    b"My secret note",\n)?;\nitem_manager.batch(vec![&item].into_iter(), None)?;\n')))),(0,m.kt)("h2",{id:"fetching-items"},"Fetching items"),(0,m.kt)("p",null,"Fetching items is very similar to fetching collections:"),(0,m.kt)("h3",{id:"simple-fetch"},"Simple fetch"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"const itemManager = collectionManager.getItemManager(collection);\nconst items = await itemManager.list();\n/*\nItems:\n{\n  data: Etebase.Item[], // Returned array of items\n  stoken: string, // The sync token for this fetch\n  ... // More fields we'll cover later\n}\n*/\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"item_mgr = col_mgr.get_item_manager(collection)\nitems = item_mgr.list()\n# {\n#   data: iter(etebase.Item), // Returned iterator of items\n#   stoken: string, // The sync token for this fetch\n#   ... // More fields we'll cover later\n# }\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"ItemManager itemManager = colMgr.getItemManager(collection);\nItemListResponse items = itemManager.list();\n/*\nItems:\n{\n  data: Item[], // Returned array of items\n  stoken: string, // The sync token for this fetch\n  ... // More fields we'll cover later\n}\n*/\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"val itemManager = colMgr.getItemManager(collection)\nval items = itemManager.list()\n/*\nItems:\n{\n  data: Item[], // Returned array of items\n  stoken: string, // The sync token for this fetch\n  ... // More fields we'll cover later\n}\n*/\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"EtebaseItemManager *item_mgr = etebase_collection_manager_get_item_manager(col_mgr, col);\nEtebaseItemListResponse *item_list = etebase_item_manager_list(item_mgr, NULL);\n/*\nItems:\n{\n  etebase_item_list_response_get_data(): EtebaseItem[] // Returned array of items\n  etebase_item_list_response_get_stoken(): const char * // The sync token for this fetch\n  ... // More fields we'll cover later\n}\n*/\n\n// Cleanup\netebase_item_list_response_destroy(item_list);\netebase_item_manager_destroy(item_mgr);\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"let item_manager = collection_manager.item_manager(collection)?;\n\nlet items = item_manager.list(None)?;\n/*\nitems: ItemListResponse<Item> {\n  data: Vec<Item>, // Returned array of items\n  stoken: Option<String>, // The sync token for this fetch\n  ... // More fields we'll cover later\n}\n*/\n")))),(0,m.kt)("p",null,"The number of returned items is limited by default, and you can control this limit by passing a different limit parameter as we'll see in the next example:"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"const items = await itemManager.list({ limit: 50 });\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"item_mgr = col_mgr.get_item_manager(collection)\nitems = item_mgr.list(FetchOptions().limit(50))\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"ItemManager itemManager = colMgr.getItemManager(collection);\nItemListResponse items = itemManager.list(new FetchOptions().limit(50));\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"val itemManager = colMgr.getItemManager(collection)\nval items = itemManager.list(FetchOptions().limit(50))\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"EtebaseItemManager *item_mgr = etebase_collection_manager_get_item_manager(col_mgr, col);\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_limit(fetch_options, 50);\nEtebaseItemListResponse *col_list = etebase_item_manager_list(item_mgr, fetch_options);\n\n// Cleanup\netebase_fetch_options_destroy(fetch_options);\netebase_item_list_response_destroy(col_list);\netebase_item_manager_destroy(col_mgr);\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"let item_manager = collection_manager.item_manager(collection, None)?;\nlet items = item_manager.list(Some(&FetchOptions::new().limit(50)))?;\n")))),(0,m.kt)("h3",{id:"only-fetch-recent-changes"},"Only fetch recent changes"),(0,m.kt)("p",null,"We can use the ",(0,m.kt)("inlineCode",{parentName:"p"},"stoken")," we have gotten in previous fetches to only return changed items."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},'const stoken = "..."; // An stoken we got previously (items.stoken)\n\nconst items = await itemManager.list({ stoken });\n'))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},'stoken = "..."  # An stoken we got previously e.g. items.stoken\n\nitems = item_mgr.list(FetchOptions().stoken(stoken))\n'))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},'String stoken = "..."; // An stoken we got previously (items.stoken)\n\nItemListResponse items = itemManager.list(new FetchOptions().stoken(stoken));\n'))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},'val stoken = "..." // An stoken we got previously (items.stoken)\n\nval items = itemManager.list(FetchOptions().stoken(stoken))\n'))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},'const char *stoken = "..."; // An stoken we got previously e.g. items.stoken\n\nEtebaseItemManager *item_mgr = etebase_collection_manager_get_item_manager(col_mgr, col);\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_stoken(fetch_options, stoken);\nEtebaseItemListResponse *col_list = etebase_item_manager_list(item_mgr, NULL);\n\n// Cleanup\netebase_fetch_options_destroy(fetch_options);\netebase_item_list_response_destroy(col_list);\netebase_item_manager_destroy(col_mgr);\n'))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},'let stoken = "..." // An stoken we got previously (items.stoken())\n\nlet items = item_manager.list(Some(&FetchOptions::new().limit(stoken)))?;\n')))),(0,m.kt)("h3",{id:"fetch-in-chunks"},"Fetch in chunks"),(0,m.kt)("p",null,"We can use a combination of limit and stoken to fetch the changes in chunks rather than all at once. This is more resistant to spotty internet connections, and means we can show data to users faster."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"let stoken = null;\nwhile (true) {\n  const items = await itemManager.list({ stoken, limit: 30 });\n  stoken = items.stoken;\n\n  processNewItems(items.data);\n\n  if (items.done) {\n    break;\n  }\n}\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"stoken = None\ndone = False\nwhile not done:\n    items = item_mgr.list(FetchOptions().stoken(stoken).limit(30))\n    stoken = items.stoken\n    done = items.done\n\n    process_new_items(items.data)\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"String stoken = null;\nboolean done = false;\nwhile (!done) {\n    ItemListResponse items = itemManager.list(new FetchOptions().stoken(stoken).limit(30));\n    stoken = items.getStoken();\n    done = items.isDone();\n\n    process_new_items(items.getData());\n}\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"var stoken: String? = null\nvar done = false\nwhile (!done) {\n    val items = itemManager.list(FetchOptions().stoken(stoken).limit(30))\n    stoken = items.stoken\n    done = items.isDone\n\n    process_new_items(items.data)\n}\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"char *stoken = NULL;\nbool done = 0;\nwhile (!done) {\n    EtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\n    etebase_fetch_options_set_stoken(fetch_options, stoken);\n    etebase_fetch_options_set_limit(fetch_options, 30);\n    EtebaseItemListResponse *item_list = etebase_item_manager_list(item_mgr, fetch_options);\n\n    if (stoken) {\n        free(stoken);\n    }\n    stoken = strdup(etebase_item_list_response_get_stoken(item_list));\n    done = etebase_item_list_response_is_done(item_list);\n\n    uintptr_t data_len = etebase_item_list_response_get_data_length(item_list);\n    const EtebaseItem *data[data_len];\n    etebase_item_list_response_get_data(item_list, data);\n\n    process_new_items(data, data_len);\n\n    etebase_fetch_options_destroy(fetch_options);\n    etebase_item_list_response_destroy(item_list);\n}\n\nif (stoken) {\n    free(stoken);\n}\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"let mut stoken: Option<&str> = None;\nlet mut items: ItemListResponse<Item>;\nloop {\n    items = item_manager.list(\n        Some(&FetchOptions::new().stoken(stoken).limit(30))\n    )?;\n    stoken = items.stoken();\n\n    process_new_items(items.data());\n    if items.done() {\n        break\n    }\n}\n")))),(0,m.kt)("h3",{id:"fetch-by-uid"},"Fetch by ",(0,m.kt)("inlineCode",{parentName:"h3"},"uid")),(0,m.kt)("p",null,"Sometimes we don't care about getting the whole list of items, and we are just interested in fetching one item based on its ",(0,m.kt)("inlineCode",{parentName:"p"},"uid"),". We can do it like this:"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"const item = await itemManager.fetch(itemUid);\n\n// Can optionally pass stoken to only return the item if changed:\nconst item = await itemManager.fetch(itemUid, { stoken });\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"item = item_mgr.fetch(item_uid)\n\n# Can optionally pass stoken to only return the item if changed:\nitem = item_mgr.fetch(item_uid, FetchOptions().stoken(stoken))\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"Item item = itemManager.fetch(itemUid);\n\n// Can optionally pass stoken to only return the item if changed:\nItem item = itemManager.fetch(itemUid, new FetchOptions().stoken(stoken));\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"val item = itemManager.fetch(itemUid);\n\n// Can optionally pass stoken to only return the item if changed:\nval item = itemManager.fetch(itemUid, FetchOptions().stoken(stoken))\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"EtebaseItem *item = etebase_item_manager_fetch(item_mgr, item_uid, NULL);\n\n// Can optionally pass stoken to only return the item if changed:\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_stoken(fetch_options, stoken);\nEtebaseItem *item = etebase_item_manager_fetch(item_mgr, item_uid, fetch_options);\netebase_fetch_options_destroy(fetch_options);\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"let item = item_manager.fetch(item_uid, None)?;\n\n// Can optionally pass stoken to only return the item if changed:\nlet item = item_manager.fetch(item_uid, Some(&FetchOptions::new().stoken(stoken)))?;\n")))),(0,m.kt)("h3",{id:"fetch-multiple-by-uid"},"Fetch multiple by ",(0,m.kt)("inlineCode",{parentName:"h3"},"uid")),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"const items = await itemManager.fetchMulti([item1Uid, item2Uid]);\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"items = item_mgr.fetch_multi([item1_uid, item2_uid])\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"ItemListResponse items = itemManager.fetchMulti(new String[] {item1Uid, item2Uid});\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"val items = itemManager.fetchMulti(arrayOf(item1Uid, item2Uid));\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"const char *uids[] = { item1_uid, item2_uid };\nEtebaseItemListResponse *items = etebase_item_manager_fetch_multi(item_mgr, uids, ETEBASE_UTILS_C_ARRAY_LEN(uids), NULL);\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"let items = item_manager.fetch_multi(vec![&item1_uid, &item2_uid].into_iter(), None)?;\n")))),(0,m.kt)("h3",{id:"fetch-a-group-of-items"},"Fetch a group of items"),(0,m.kt)("p",null,"In addition to fetching all of the changes in a collection, you can also limit the fetching to only a specific subset of items. This is useful, for example, if your data is structured hierarchically (e.g. a directory tree), and you are only interested in refreshing the currently viewed directory."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"const toFetch = [item1, item2, item3];\nconst items = await itemManager.fetchUpdates(toFetch);\n\n// Can optionally pass stoken to limit to new changes\nconst items = await itemManager.fetchUpdates(toFetch, { stoken });\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"to_fetch = [item1, item2, item3]\nitems = item_mgr.fetch_updates(to_fetch)\n\n# Can optionally pass stoken to only return the items if changed:\ncollection = col_mgr.fetch_updates(to_fetch, FetchOptions().stoken(stoken))\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"Item[] toFetch = new Item[] {item1, item2, item3};\nItemListResponse items = itemManager.fetchUpdates(to_fetch);\n\n// Can optionally pass stoken to only return the item if changed:\nFetchOptions fetchOptions = new FetchOptions().stoken(stoken);\nItemListResponse items = itemManager.fetchUpdates(to_fetch, fetch_options);\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"val toFetch = arrayOf(item1, item2, item3)\nval items = itemManager.fetchUpdates(to_fetch)\n\n// Can optionally pass stoken to only return the item if changed:\nval fetchOptions = FetchOptions().stoken(stoken)\nval items = itemManager.fetchUpdates(to_fetch, fetch_options)\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"const EtebaseItem *items[] = { item1, item2, item3 };\nEtebaseItemListResponse *item_list = etebase_item_manager_fetch_updates(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n\n// Cleanup\netebase_item_list_response_destroy(item_list);\n\n\n// Can optionally pass stoken to only return the item if changed:\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_stoken(fetch_options, stoken);\nEtebaseItemListResponse *item_list = etebase_item_manager_fetch_updates(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), fetch_options);\n\n// Cleanup\netebase_fetch_options_destroy(fetch_options);\netebase_item_list_response_destroy(item_list);\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"let to_fetch = vec![&item1, &item2, &item3];\nlet items = item_manager.fetch_updates(to_fetch.into_iter(), None)?;\n\n// Can optionally pass stoken to only return the item if changed:\nlet fetch_options = FetchOptions::new().stoken(stoken);\nlet items = item_manager.fetch_updates(to_fetch.into_iter(), Some(&fetch_options))?;\n")))),(0,m.kt)("h2",{id:"modifying-and-deleting-items"},"Modifying and deleting items"),(0,m.kt)("p",null,"Modifying items is easy, it's just a matter of changing them and uploading them."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},'await item.setContent("new secret content");\n\nawait itemManager.batch([item]);\n'))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},'item.content = "new secret content"\n\nitem_mgr.batch([item])\n'))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},'ItemMetadata itemMeta = item.getMeta();\nitemMeta.setName("Name");\nitem.setMeta(itemMeta);\n\nitemManager.batch(new Item[] {item});\n'))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},'val itemMeta = item.meta\nitemMeta.name = "Name"\nitem.meta = itemMeta\n\nitemManager.batch(arrayOf(item))\n'))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},'EtebaseItemMetadata *item_meta = etebase_item_get_meta(item);\netebase_item_metadata_set_name(item_meta, "Name");\netebase_item_set_meta(item, item_meta);\netebase_item_metadata_destroy(item_meta);\n\nconst EtebaseItem *items[] = { item };\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n'))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},'let mut item_meta = item.meta()?;\nitem_meta.set_name("Name");\nitem.set_meta(&item_meta)?;\n\nitem_manager.batch(vec![&item].into_iter(), None)?;\n')))),(0,m.kt)("p",null,"Deleting is even easier:"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"item.delete();\n\nawait itemManager.batch([item]);\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"item.delete()\n\nitem_mgr.batch([item])\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"item.delete();\n\nitemManager.batch(new Item[] {item});\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"item.delete()\n\nitemManager.batch(arrayOf(item))\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"etebase_item_delete(item);\n\nconst EtebaseItem *items[] = { item };\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"item.delete()?;\n\nitem_manager.batch(vec![&item].into_iter(), None)?;\n")))),(0,m.kt)("h2",{id:"uploading-multiple-items"},"Uploading multiple items"),(0,m.kt)("p",null,"As you saw in the previous examples, unlike the collection's ",(0,m.kt)("inlineCode",{parentName:"p"},"upload"),", ",(0,m.kt)("inlineCode",{parentName:"p"},"batch")," accepts an array of items. This can be used for uploading multiple items at once:"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"await itemManager.batch([item1, item2, item3, ...]);\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"item_mgr.batch([item1, item2, item3, ...])\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"itemManager.batch(new Item[] {item1, item2, item3, ...});\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"itemManager.batch(arrayOf(item1, item2, item3, ...))\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"const EtebaseItem *items[] = { item1, item2, item3, ... };\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"item_manager.batch(vec![&item1, &item2, &item3, ...].into_iter(), None)?;\n")))),(0,m.kt)("h2",{id:"advanced-uploads-and-transactions"},"Advanced uploads and transactions"),(0,m.kt)("p",null,"In the examples above we always uploaded the items in a way that overwrote whatever is on the server, regardless if it has changed since we last fetched it, or not. While this is fine in many cases, in some cases you want to prevent that in order to ensure the consistency of data."),(0,m.kt)("h3",{id:"transactions"},"Transactions"),(0,m.kt)("p",null,"The easiest way to ensure consistency is just to use transactions. Transactions make sure that what we think is the most recent version, really is, and will fail otherwise. This consistency check is done across all of the items, and if one item fails the check, the whole transaction fails."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},'// -> On device A:\nconst item1 = await.itemManager.fetch(itemUid1);\nconst item2 = await.itemManager.fetch(itemUid2);\n\n\n// -> On device B:\nconst item1 = await.itemManager.fetch(itemUid1);\nawait item1.setContent("something else for item 1");\nawait itemManager.batch([item1]);\n\n\n// -> On device A (using the previously saved item)\nawait item1.setContent("new content for item 1");\nawait item2.setContent("new content for item 2");\n\n// Will fail because item1 changed on device B\nawait itemManager.transaction([item1, item2]);\n// Will succeed\nawait itemManager.batch([item1, item2]);\n// Will succeed because item2 hasn\'t changed on device B\nawait itemManager.transaction([item2]);\n'))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},'# -> On device A:\nitem1 = item_mgr.fetch(item_uid1)\nitem2 = item_mgr.fetch(item_uid2)\n\n\n# -> On device B:\nitem1 = item_mgr.fetch(item_uid1)\nitem1.content = b"something else for item 1"\nitem_mgr.batch([item1])\n\n\n# -> On device A (using the previously saved item)\nitem1.content = b"new content for item 1"\nitem2.content = b"new content for item 2"\n\n# Will fail because item1 changed on device B\nitem_mgr.transaction([item1, item2])\n# Will succeed\nitem_mgr.batch([item1, item2])\n# Will succeed because item2 hasn\'t changed on device B\nitem_mgr.transaction([item2])\n'))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},'// -> On device A:\nItem item1 = itemManager.fetch(itemUid1);\nItem item2 = itemManager.fetch(itemUid2);\n\n\n// -> On device B:\nItem item1 = itemManager.fetch(itemUid1);\nitem1.setContent("Something else for item 1")\nitemManager.batch(new Item[] {item1});\n\n\n// -> On device A (using the previously saved item)\nitem1.setContent("New content for item 1");\nitem2.setContent("New content for item 2");\n\n// Will fail because item1 changed on device B\nitemManager.transaction(new Item[] {item1, item2});\n// Will succeed\nitemManager.batch(new Item[] {item1, item2});\n// Will succeed because item2 hasn\'t changed on device B\nitemManager.transaction(new Item[] {item2});\n'))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},'// -> On device A:\nval item1 = itemManager.fetch(itemUid1)\nval item2 = itemManager.fetch(itemUid2)\n\n\n// -> On device B:\nval item1 = itemManager.fetch(itemUid1)\nitem1.content = "Something else for item 1"\nitemManager.batch(arrayOf(item1))\n\n\n// -> On device A (using the previously saved item)\nitem1.content = "New content for item 1"\nitem2.content = "New content for item 2"\n\n// Will fail because item1 changed on device B\nitemManager.transaction(arrayOf(item1, item2))\n// Will succeed\nitemManager.batch(arrayOf(item1, item2))\n// Will succeed because item2 hasn\'t changed on device B\nitemManager.transaction(arrayOf(item2))\n'))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},'// -> On device A:\nEtebaseItem *item1 = etebase_item_manager_fetch(item_mgr, item1_uid, NULL);\nEtebaseItem *item2 = etebase_item_manager_fetch(item_mgr, item2_uid, NULL);\n\n// -> On device B:\nEtebaseItem *item1 = etebase_item_manager_fetch(item_mgr, item1_uid, NULL);\nconst char tmp[] = "Something else for item 1";\netebase_item_set_content(item1, tmp, strlen(tmp));\n\nconst EtebaseItem *items[] = { item1 };\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n\netebase_item_destroy(item1);\n\n\n// -> On device A (using the previously saved item)\nconst char tmp[] = "New content for item 1";\netebase_item_set_content(item1, tmp, strlen(tmp));\nconst char tmp2[] = "New content for item 2";\netebase_item_set_content(item2, tmp2, strlen(tmp2));\n\n// Will fail because item1 changed on device B\nconst EtebaseItem *items[] = { item1, item2 };\netebase_item_manager_transaction(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n// Will succeed\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n// Will succeed because item2 hasn\'t changed on device B\nconst EtebaseItem *items2[] = { item2 };\netebase_item_manager_transaction(item_mgr, items2, ETEBASE_UTILS_C_ARRAY_LEN(items2), NULL);\n\netebase_item_destroy(item2);\netebase_item_destroy(item1);\n'))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},'// -> On device A:\nlet mut item1 = item_manager.fetch(item_uid1, None)?;\nlet mut item2 = item_manager.fetch(item_uid2, None)?;\n\n\n// -> On device B:\nlet mut item1 = item_manager.fetch(item_uid1, None)?;\nitem1.set_content(b"Something else for item 1")?;\nitem_manager.batch(vec![&item1].into_iter(), None)?;\n\n\n// -> On device A (using the previously saved item)\nitem1.set_content(b"New content for item 1")?;\nitem2.set_content(b"New content for item 2")?;\n\n// Will fail because item1 changed on device B\nitem_manager.transaction(vec![&item1, &item2].into_iter(), None)?;\n// Will succeed\nitem_manager.batch(vec![&item1, &item2].into_iter(), None)?;\n// Will succeed because item2 hasn\'t changed on device B\nitem_manager.transaction(vec![&item2].into_iter(), None)?;\n')))),(0,m.kt)("h3",{id:"using-stoken"},"Using ",(0,m.kt)("inlineCode",{parentName:"h3"},"stoken")),(0,m.kt)("p",null,"Like with collections, transactions will only fail if the items themselves have changed, but will not fail if another item of the collection has changed. In some cases we want to have collection-wide consistency and want to make sure nothing has changed."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},'// -> On device A:\nconst stoken = collection.stoken;\nconst item = await.itemManager.fetch(itemUid);\n\n\n// -> On device B:\nconst anotherItem = await.itemManager.fetch(anotherItemUid);\nawait anotherItem.setContent("content for another item");\nawait itemManager.batch([anotherItem]);\n\n\n// -> On device A (using the previously saved items and stoken)\nawait item.setContent("new secret content");\n\n// Both will fail\nawait itemManager.transaction([item], null, { stoken });\nawait itemManager.batch([item], null, { stoken });\n\n// Both will succeed\nawait itemManager.transaction([item]);\nawait itemManager.batch([item]);\n'))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},'# -> On device A:\nstoken = collection.stoken\nitem = item_mgr.fetch(item_uid)\n\n\n# -> On device B:\nanother_item = item_mgr.fetch(another_item_uid)\nanother_item.content = b"content for another item"\nitem_mgr.batch([another_item])\n\n\n# -> On device A (using the previously saved item and stoken)\nitem.content = b"new secret content"\n\n# Both will fail\nfetch_options = FetchOptions().stoken(stoken)\nitem_mgr.transaction([item], fetch_options=fetch_options)\nitem_mgr.batch([item], fetch_options=fetch_options)\n\n# Both will succeed\nitem_mgr.transaction([item])\nitem_mgr.batch([item])\n'))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},'// -> On device A:\nString stoken = collection.stoken\nItem item = itemManager.fetch(itemUid);\n\n\n// -> On device B:\nItem anotherItem = itemManager.fetch(anotherItemUid);\nanotherItem.setContent("content for another item")\nitemManager.batch(new Item[] {anotherItem});\n\n\n// -> On device A (using the previously saved item and stoken)\nitem.setContent("new secret content")\n\n// Both will fail\nFetchOptions fetchOptions = new FetchOptions().stoken(stoken);\nitemManager.transaction(new Item[] {item}, null, fetchOptions);\nitemManager.batch(new Item[] {item}, null, fetchOptions);\n\n// Both will succeed\nitemManager.transaction(new Item[] {item});\nitemManager.batch(new Item[] {item});\n'))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},'// -> On device A:\nval stoken = collection.stoken\nval item = itemManager.fetch(itemUid)\n\n\n// -> On device B:\nval anotherItem = itemManager.fetch(anotherItemUid)\nanotherItem.content = "content for another item"\nitemManager.batch(arrayOf(anotherItem))\n\n\n// -> On device A (using the previously saved item and stoken)\nitem.content = "new secret content"\n\n// Both will fail\nval fetchOptions = FetchOptions().stoken(stoken)\nitemManager.transaction(arrayOf(item), null, fetchOptions)\nitemManager.batch(arrayOf(item), null, fetchOptions)\n\n// Both will succeed\nitemManager.transaction(arrayOf(item))\nitemManager.batch(arrayOf(item))\n'))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},'// -> On device A:\nEtebaseItem *item = etebase_item_manager_fetch(item_mgr, item_uid, NULL);\nconst char *stoken = etebase_collection_get_stoken(col);\n\n{\n    // -> On device B:\n    EtebaseItem *another_item = etebase_item_manager_fetch(item_mgr, another_item_uid, NULL);\n    const char tmp[] = "content for another item";\n    etebase_item_set_content(item1, tmp, strlen(tmp));\n\n    const EtebaseItem *items[] = { another_item };\n    etebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n\n    etebase_item_destroy(another_item);\n}\n\n\n// -> On device A (using the previously saved item and stoken)\nconst char tmp[] = "new secret content";\netebase_item_set_content(item, tmp, strlen(tmp));\n\n\n// Both will fail\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_stoken(fetch_options, stoken);\nconst EtebaseItem *items[] = { item };\netebase_item_manager_transaction(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), fetch_options);\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), fetch_options);\n\netebase_fetch_options_destroy(fetch_options);\n\n// Both will succeed\netebase_item_manager_transaction(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n\netebase_item_destroy(item);\n'))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},'// -> On device A:\nlet stoken = collection.stoken();\nlet mut item = item_manager.fetch(item_uid, None)?;\n\n\n// -> On device B:\nlet mut another_item = item_manager.fetch(another_item_uid, None)?;\nanother_item.set_content(b"content for another item")?;\nitem_manager.batch(vec![&another_item].into_iter(), None)?;\n\n\n// -> On device A (using the previously saved item and stoken)\nitem.set_content(b"new secret content")?;\n\n// Both will fail\nlet fetch_options = FetchOptions::new().stoken(stoken);\nitem_manager.transaction(vec![&item].into_iter(), Some(&fetch_options))?;\nitem_manager.batch(vec![&item].into_iter(), Some(&fetch_options))?;\nBoth will\n// Both will succeed\nitem_manager.transaction(vec![&item].into_iter(), None)?;\nitem_manager.batch(vec![&item].into_iter(), None)?;\n')))),(0,m.kt)("h3",{id:"additional-dependencies"},"Additional dependencies"),(0,m.kt)("p",null,"Sometimes we may want a ",(0,m.kt)("inlineCode",{parentName:"p"},"transaction")," or ",(0,m.kt)("inlineCode",{parentName:"p"},"batch")," upload to fail if some items have changed but not upload them. These are called dependencies and can be passed to both transactions and batches."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},'// -> On device A:\nconst item1 = await.itemManager.fetch(itemUid1);\nconst item2 = await.itemManager.fetch(itemUid2);\n\n\n// -> On device B:\nconst item1 = await.itemManager.fetch(itemUid1);\nawait item1.setContent("something else for item 1");\nawait itemManager.batch([item1]);\n\n\n// -> On device A (using the previously saved items and stoken)\nawait item2.setContent("new secret content");\n\n// Both will fail because item1 changed\nawait itemManager.transaction([item2], [item1]);\nawait itemManager.batch([item2], [item1]);\n\n// Can even use the item in both the list and deps in batch\n// Will fail because item1 changed on device B\nawait itemManager.batch([item1, item2], [item1]);\n'))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},'# -> On device A:\nitem1 = item_mgr.fetch(item_uid1)\nitem2 = item_mgr.fetch(item_uid2)\n\n\n# -> On device B:\nitem1 = item_mgr.fetch(item_uid1)\nitem1.content = b"something else for item 1"\nitem_mgr.batch([item1])\n\n\n# -> On device A (using the previously saved item)\nitem2.content = b"new content for item 2"\n\n# Both will fail because item1 changed\nitem_mgr.transaction([item2], [item1])\nitem_mgr.batch([item2], [item1])\n\n# Can even use the item in both the list and deps in batch\n# Will fail because item1 changed on device B\nitem_mgr.batch([item1, item2], [item1])\n'))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},'// -> On device A:\nItem item1 = itemManager.fetch(itemUid1);\nItem item2 = itemManager.fetch(itemUid2);\n\n\n// -> On device B:\nItem item1 = itemManager.fetch(itemUid1);\nitem1.setContent("Something else for item1");\nitemManager.batch(new Item[] {item1});\n\n\n// -> On device A (using the previously saved collection)\nitem2.setContent("New content for item 2");\n\n// Both will fail because item1 changed\nitemManager.transaction(new Item[] {item2}, new Item[] {item1});\nitemManager.batch(new Item[] {item2}, new Item[] {item1});\n\n// Can even use the item in both the list and deps in batch\n// Will fail because item1 changed on device B\nitemManager.batch(new Item[] {item1, item2}, new Item[] {item1});\n'))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},'// -> On device A:\nval item1 = itemManager.fetch(itemUid1)\nval item2 = itemManager.fetch(itemUid2)\n\n\n// -> On device B:\nval item1 = itemManager.fetch(itemUid1)\nitem1.content = "Something else for item1"\nitemManager.batch(arrayOf(item1))\n\n\n// -> On device A (using the previously saved collection)\nitem2.content = "New content for item 2"\n\n// Both will fail because item1 changed\nitemManager.transaction(arrayOf(item2), arrayOf(item1));\nitemManager.batch(arrayOf(item2), arrayOf(item1));\n\n// Can even use the item in both the list and deps in batch\n// Will fail because item1 changed on device B\nitemManager.batch(arrayOf(item1, item2), arrayOf(item1));\n'))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},'// -> On device A:\nEtebaseItem *item1 = etebase_item_manager_fetch(item_mgr, item1_uid, NULL);\nEtebaseItem *item2 = etebase_item_manager_fetch(item_mgr, item2_uid, NULL);\n\n\n// -> On device B:\nEtebaseItem *item1 = etebase_item_manager_fetch(item_mgr, item1_uid, NULL);\nconst char tmp[] = "Something else for item 1";\netebase_item_set_content(item1, tmp, strlen(tmp));\n\nconst EtebaseItem *items[] = { item1 };\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n\netebase_item_destroy(item1);\n\n\n// -> On device A (using the previously saved collection)\nconst char tmp2[] = "New content for item 2";\netebase_item_set_content(item2, tmp2, strlen(tmp2));\n\n// Both will fail because item1 changed\nconst EtebaseItem *items[] = { item2 };\nconst EtebaseItem *deps[] = { item1 };\netebase_item_manager_batch_deps(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), deps, ETEBASE_UTILS_C_ARRAY_LEN(deps), NULL);\netebase_item_manager_transaction_deps(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), deps, ETEBASE_UTILS_C_ARRAY_LEN(deps), NULL);\n\n// Can even use the item in both the list and deps in batch\n// Will fail because item1 changed on device B\nconst EtebaseItem *items[] = { item1, item2 };\nconst EtebaseItem *deps[] = { item1 };\netebase_item_manager_batch_deps(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), deps, ETEBASE_UTILS_C_ARRAY_LEN(deps), NULL);\n\netebase_item_destroy(item2);\netebase_item_destroy(item1);\n'))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},'// -> On device A:\nlet mut item1 = item_manager.fetch(item_uid1, None)?;\nlet mut item2 = item_manager.fetch(item_uid2, None)?;\n\n\n// -> On device B:\nlet mut item1 = item_manager.fetch(item_uid1, None)?;\nitem1.set_content(b"Something else for item1")?;\nitem_manager.batch(vec![&item1].into_iter(), None)?;\n\n\n// -> On device A (using the previously saved collection)\nitem2.set_content(b"New content for item 2")?;\n\n// Both will fail because item1 changed\nitem_manager.transaction_deps(vec![&item2].into_iter(), vec![&item1].into_iter(), None)?;\nitem_manager.batch_deps(vec![&item2].into_iter(), vec![&item1].into_iter(), None)?;\n\n// Can even use the item in both the list and deps in batch\n// Will fail because item1 changed on device B\nitem_manager.batch_deps(vec![&item1, &item2].into_iter(), vec![&item1].into_iter(), None)?;\n')))),(0,m.kt)("h3",{id:"treating-collections-as-items"},"Treating collections as items"),(0,m.kt)("p",null,"In the examples above we only covered consistency of items, but what happens if we want to ensure the collection itself is consistent with its items?\nOne case where this is useful, is if your data is ordered hierarchically (e.g. as a tree) with the collection as the root.\nIn this case, you will want to be able to create a child and have it added to the root node in the same transaction."),(0,m.kt)("p",null,"In Etebase, collections are essentially just items with some extra data, so you can use collections directly as items with just a small difference."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"// A pre-existing collection and a few items:\nconst collection = ...;\nconst item1 = ...;\nconst item2 = ...;\n\n// Get the item out of the collection\nconst colItem = collection.item;\n\n// The collection item can then be used like any other item:\nawait itemManager.transaction([colItem, item1], [item2]);\nawait itemManager.transaction([item1, item2], [colItem]);\nawait itemManager.batch([colItem, item1]);\n\n// In addition, these are true:\nassert(collection.getMeta() === colItem.getMeta());\nassert((await collection.getContent()) === (await colItem.getContent()));\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"# A pre-existing collection and a few items:\ncollection = ...\nitem1 = ...\nitem2 = ...\n\n# Get the item out of the collection\ncol_item = collection.item;\n\n# The collection item can then be used like any other item:\nitem_mgr.transaction([col_item, item1], [item2]);\nitem_mgr.transaction([item1, item2], [col_item]);\nitem_mgr.batch([col_item, item1]);\n\n# In addition, these are true:\nassert(collection.meta == col_item.meta)\nassert(collection.content == col_item.content)\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"Collection collection = ...;\nItem item1 = ...;\nItem item2 = ...;\n\n// Get the item out of the collection\nItem colItem = collection.asItem();\n\n// The collection item can then be used like any other item:\nitemManager.transaction(new Item[] {colItem, item1}, new Item[] {item2});\nitemManager.transaction(new Item[] {item1, item2}, new Item[] {colItem});\nitemManager.batch(new Item[] {colItem, item1});\n\n// In addition, these are true:\nassert (collection.getMetaRaw() == colItem.getMetaRaw());\nassert (collection.getContent() == colItem.getContent());\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"val collection = ...\nval item1 = ...\nval item2 = ...\n\n// Get the item out of the collection\nvar colItem = collection.asItem()\n\n// The collection item can then be used like any other item:\nitemManager.transaction(arrayOf(colItem, item1), arrayOf(item2)\nitemManager.transaction(arrayOf(item1, item2), arrayOf(colItem))\nitemManager.batch(arrayOf(colItem, item1))\n\n// In addition, these are true:\nassert(collection.metaRaw == colItem.metaRaw)\nassert(collection.content == colItem.content)\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"// Get the item out of the collection\nEtebaseItem *col_item = etebase_collection_as_item(col);\n\n// The collection item can then be used like any other item:\nconst EtebaseItem *items[] = { col_item, item1 };\nconst EtebaseItem *deps[] = { item2 };\netebase_item_manager_transaction_deps(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items),\n            deps, ETEBASE_UTILS_C_ARRAY_LEN(deps), NULL);\nconst EtebaseItem *items[] = { item1, item2 };\nconst EtebaseItem *deps[] = { col_item };\netebase_item_manager_transaction_deps(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items),\n            deps, ETEBASE_UTILS_C_ARRAY_LEN(deps), NULL);\nconst EtebaseItem *items[] = { col_item, item1 };\netebase_item_manager_batch(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n\n// In addition, these are true:\n// etebase_collection_get_meta_raw(col, ...) == etebase_item_get_meta_raw(col_item, ...)\n// etebase_collection_get_content(col, ...) == etebase_item_get_content(col_item, ...)\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"let collection = ...\nlet item1 = ...\nlet item2 = ...\n\n// Get the item out of the collection\nlet col_item = collection.item()?;\n\n// The collection item can then be used like any other item:\nitem_manager.transaction_deps(vec![&col_item, &item1].into_iter(), vec![&item2].into_iter(), None)?;\nitem_manager.transaction_deps(vec![&item1, &item2].into_iter(), vec![&col_item].into_iter(), None)?;\nitem_manager.batch(vec![&col_item, &item1].into_iter(), None)?;\n\n// In addition, these are true:\nassert_eq!(collection.meta_raw()?, col_item.meta_raw()?);\nassert_eq!(collection.content()?, col_item.content()?);\n")))),(0,m.kt)("p",null,"You can also fetch the collection as an item from all of the item API functions:"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"const itemManager = collectionManager.getItemManager(collection);\n\n// Will return the collection item as part of the list:\nconst items = await itemManager.list({ withCollection: true });\n\n// Assuming the collection is the first item returned:\nconst colItem = items.data[0];\nassert(colItem.uid === collection.uid);\n\n// You can also fetch collection items based on UID:\nconst colItem = await itemManager.fetch(collection.uid);\n\n// Or fetch updates of the collection along with other items:\nconst items = await itemManager.fetchUpdates([collection.item, item1]);\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},"item_mgr = col_mgr.get_item_manager(collection)\n\n# Will return the collection item as part of the list:\nfetch_options = FetchOptions().with_collection(true)\nitems = item_mgr.list(fetch_options);\n\n# Assuming the collection is the first item returned:\ncol_item = items.data[0];\nassert(col_item.uid == collection.uid)\n\n# You can also fetch collection items based on UID:\ncol_item = item_mgr.fetch(collection.uid);\n\n# Or fetch updates of the collection along with other items:\nitems = item_mgr.fetch_updates([collection.item, item1]);\n"))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},"ItemManager itemManager = colMgr.getItemManager(collection);\n\nItemListResponse items = itemManager.list(new FetchOptions().with_collection(true));\n\n// Assuming the collection is the first item returned:\nItem colItem = items.getData()[0];\nassert (colItem.uid === collection.uid);\n\n// You can also fetch collection items based on UID:\nItem colItem = itemManager.fetch(collection.uid);\n\n// Or fetch updates of the collection along with other items:\nItemListResponse items = itemManager.fetchUpdates(new Item[] { collection.asItem(), item1 });\n"))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},"val itemManager = colMgr.getItemManager(collection)\n\nval items = itemManager.list(FetchOptions().with_collection(true))\n\n// Assuming the collection is the first item returned:\nval colItem = items.getData()[0]\nassert(colItem.uid === collection.uid)\n\n// You can also fetch collection items based on UID:\nval colItem = itemManager.fetch(collection.uid)\n\n// Or fetch updates of the collection along with other items:\nval items = itemManager.fetchUpdates(arrayOf(collection.asItem(), item1))\n"))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"EtebaseItemManager *item_mgr = etebase_collection_manager_get_item_manager(col_mgr, col);\n\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_with_collection(fetch_options, true);\netebase_fetch_options_set_limit(fetch_options, 1);\nEtebaseItemListResponse *item_list = etebase_item_manager_list(item_mgr, fetch_options);\netebase_fetch_options_destroy(fetch_options);\n\n// Assuming the collection is the first item returned:\nconst EtebaseItem *list_items[1];\netebase_item_list_response_get_data(item_list, list_items);\nEtebaseItem *col_item = list_items[0];\n// This is true:\n// etebase_item_get_uid(item) == etebase_collection_get_uid(col)\n\n// You can also fetch collection items based on UID:\nEtebaseItem *col_item = etebase_item_manager_fetch(item_mgr, col_uid, NULL);\n\n// Or fetch updates of the collection along with other items:\nconst EtebaseItem *items[] = { col_item, item1 };\nEtebaseItemListResponse *item_list = etebase_item_manager_fetch_updates(item_mgr, items, ETEBASE_UTILS_C_ARRAY_LEN(items), NULL);\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},"let item_manager = collection_manager.item_manager(&collection)?;\n\nlet items = item_manager.list(Some(&FetchOptions::new().with_collection(true)))?;\n\n// Assuming the collection is the first item returned:\nlet col_item = &items.data()[0];\nassert_eq!(col_item.uid(), collection.uid());\n\n// You can also fetch collection items based on UID:\nlet col_item = item_manager.fetch(collection.uid(), None)?;\n\n// Or fetch updates of the collection along with other items:\nlet items = item_manager.fetch_updates(vec![&collection.item()?, &item1].into_iter(), None);\n")))),(0,m.kt)("h2",{id:"subscriptions-live-updates"},"Subscriptions (live updates)"),(0,m.kt)("p",null,"Some applications are interactive in nature and their data changes often. For these applications it's useful to be able to subscribe to live-updates so your app gets notified the moment data is changed. This is what live updates are for."),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},"const subscription = await itemMgr.subscribeChanges((items) => {\n    /*\n    items:\n    {\n      data: Etebase.Item[], // Returned array of items\n      stoken: string, // The sync token for this fetch\n      ... // More fields we'll cover later\n    }\n\n    This is the same as the list response above.\n    */\n});\n\n// Unsubscribe from updates:\nsubscription.unsubscribe();\n"))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("p",null,"Subscriptions are only supported in JavaScript at the moment. Please open a ticket if you would like to see it implemented.")),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("p",null,"Subscriptions are only supported in JavaScript at the moment. Please open a ticket if you would like to see it implemented.")),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("p",null,"Subscriptions are only supported in JavaScript at the moment. Please open a ticket if you would like to see it implemented.")),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("p",null,"Subscriptions are only supported in JavaScript at the moment. Please open a ticket if you would like to see it implemented.")),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("p",null,"Subscriptions are only supported in JavaScript at the moment. Please open a ticket if you would like to see it implemented."))),(0,m.kt)("h2",{id:"binary-content"},"Binary content"),(0,m.kt)("p",null,"In the examples above content was always a string. However, content is actually a binary blob of data, not a string. Using it as a string is just a convenience."),(0,m.kt)("p",null,"Here is how you can control the formatting of the data:"),(0,m.kt)(o.Z,{mdxType:"CodeTabs"},(0,m.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-js"},'// default, returns a Uint8Array\nitem.getContent();\n// tries to convert the binary data to a string and returns that\nitem.getContent(Etebase.OutputFormat.String);\n\n// Sets the content to a binary blob\nitem.setContent(Uint8Array.from([72, 101, 108, 108, 111]));\n// Sets the content to a string\nitem.setContent("Hello");\n'))),(0,m.kt)(s.Z,{value:"py",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-python"},'# The Python API returns `bytes` by default\nitem.content\n# Try decoding the binary data to a UTF-8 string\nitem.content.decode()\n\n# Sets the content to some byte array\nitem.content = b"Some bytes"\n# Set the content to a string\nitem.content = "Some bytes".encode()\n'))),(0,m.kt)(s.Z,{value:"java",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-java"},'// The Java API returns `byte[]` by default\nitem.getContent();\n// Try decoding the binary data to a UTF-8 string and return that\nitem.getContentString();\n\n// Sets the content to a binary blob\nitem.setContent("Bla".getBytes("UTF-8"));\n// Sets the content to a string\nitem.setContent("Hello");\n'))),(0,m.kt)(s.Z,{value:"kt",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-kotlin"},'// The Java API returns `byte[]` by default\nitem.content\n// Try decoding the binary data to a UTF-8 string and return that\nitem.contentString\n\n// Sets the content to a binary blob\nitem.content = "Bla".toByteArray()\n// Sets the content to a string\nitem.content = "Hello"\n'))),(0,m.kt)(s.Z,{value:"c",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-c"},"// The C API always works on binary data,\n// This means content is *not* NULL terminated!\n\n// It's generally fastest to just try to get the content into a buffer\n// if we think it's likely to be under a certain size.\nchar tmp[500];\nintptr_t len = etebase_item_get_content(item, tmp, sizeof(tmp));\n\nif (len < 0) {\n    // Error\n} else if (len > sizeof(tmp)) {\n    // This means we should allocate a buffer of size len to fetch into\n    char *tmp2 = malloc(len);\n    etebase_item_get_content(item, tmp2, len);\n    // Do something with tmp2\n    free(tmp2);\n}\n\n// As said above, content is not null terminated.\n// To get the content as a null terminated string:\nchar tmp[500];\nintptr_t len = etebase_item_get_content(item, tmp, sizeof(tmp));\n\nif (len < 0) {\n    // Error\n} else {\n    tmp[len] = 0;\n}\n"))),(0,m.kt)(s.Z,{value:"rs",mdxType:"TabItem"},(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-rust"},'// The rust API returns `Vec<u8>` by default\nitem.content()?;\n// Try decoding the binary data to a UTF-8 string and return that\nString::from_utf8(item.content()?);\n\n// Sets the content to a binary blob\nitem.set_content(b"Bla")?;\n// Sets the content from a string\nitem.set_content("Hello".as_bytes())?;\n')))))}g.isMDXComponent=!0}}]);